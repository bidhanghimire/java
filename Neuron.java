packaqge NeuralNetClasses;

import mathClasses.IActivationFunction;
import mathClasses.RandomNumberGenerator;
import java.util.ArrayList;


/**
 *
 * Neuron
 * Neuron class stores no. of inputs, outputs, weights,bias activation function and the value
 * of the output before activation.
 * This class includes all the set and get methods to obtain the values specified above  and a compute method to calculate customer ratings and
 * derivative method for differentiating customer function.
 * Tostring method is used for displaying outputs.
 */
public class Neuron
{

    /**
     * Weights for a neuron
     */
    protected ArrayList<Double> weight;
    /**
     * stores inputs to the neuron
     */
    private ArrayList<Double> input;
    /**
     * Output of this neuron, generated by the activation function.
     */
    private Double output;
    /**
     * input for activation function.
     */
    private Double outputBeforeActivation;

    /**
     * Number of Inputs initalized to 0 initially
   **/
    private int numberOfInputs = 0;

    /**
     * Bias of the neuron. It should be always 1.0, except for the first layer.
     */
    protected Double bias = 1.0;
    /**
     * Activation function of this neuron
     */
    private IActivationFunction activationFunction;
//   private IActivationFunction.ActivationFunctionENUM functionName;

    /**
     * Neuron dummy constructor
     */
    public Neuron()
    {
    }
    /**
     * Neuron constructor
     * @param numberofinputs Number of Inputs
     */

    // initialization of number of inputs and weights
    public Neuron(int numberofinputs)
    {
     	numberOfInputs = numberofinputs;
     	weight = new ArrayList<>(numberofinputs + 1);
     	input = new ArrayList<>(numberofinputs);
    }
    /**
     * Neuron constructor
     * @param numberofinputs Number of inputs
     * @param iaf Activation function
     */
    public Neuron(int numberofinputs,IActivationFunction iaf)
    {
		 numberOfInputs = numberofinputs;
		 weight = new ArrayList<>(numberofinputs + 1);
		 input = new ArrayList<>(numberofinputs);
		 activationFunction = iaf;
    }

    /**
     * initial
     * random initialization of weight of neuron
     */
    public void inital()
    {
     	if(numberOfInputs>0)
     	{
     		for(int count=0;count<=numberOfInputs;count++)
     		{
     		  double nextWeight = RandomNumberGenerator.GenerateNext();
     		  try
    		  {
        		this.weight.set(count, nextWeight);
       		  }
       		  catch(IndexOutOfBoundsException ignore)
       		  {
       			this.weight.add(nextWeight);
        	  }
      		 }
     	}
    }

    /**
     * setInputs
     * Sets a vector of double-precision values to the neuron input
     * @param values vector of values applied at the neuron input
     */
    public void setInputs(double [] values)
    {
        if(values.length == numberOfInputs)
        {
            for(int count = 0; count < numberOfInputs; count++)
            {
                try
                {
                    input.set(count, values[count]);
                }
                catch(IndexOutOfBoundsException iobe)
                {
                    input.add(values[count]);
                }
            }
        }
    }

    /**
     * setInputs
     * Sets an array of values to the neuron's input
     * @param values
     */
    public void setInputs(ArrayList<Double> values)
    {
        if(values.size() == numberOfInputs)
        {
            input = values;
        }
    }

    /**
     * getArrayInputs
     * @return Returns the neuron's inputs in an ArrayList
     */
    public ArrayList<Double> getArrayInputs()
    {
        return input;
    }

    /**
     * getInputs
     * @return Return the neuron's inputs in a vector
     */
    public double[] getInputs()
    {
        double[] inputs = new double[numberOfInputs];
        for (int i = 0; i < numberOfInputs; i++)
        {
            inputs[i] = this.input.get(i);
        }
        return inputs;
    }

    /**
     * setInput
     * Sets a real value at the ith java position of the neuron's inputs
     * @param c neuron input java index
     * @param value value to be set in the input
     */
    public void setInput(int c,double value)
    {
        if(c>=0 && c<numberOfInputs)
        {
            try
            {
                input.set(c, value);
            }
            catch(IndexOutOfBoundsException iobe)
            {
                input.add(value);
            }
        }
    }

    /**
     * getInput
     * @param i ith java position at the input
     * @return Returns the ith java input
     */
    public double getInput(int i)
    {
        return input.get(i);
    }

    /**
     * getWeights
     * @return Returns the neuron's weights in the form of vector
     */
    public double[] getWeights()
    {
        double[] weights = new double[numberOfInputs + 1];
        for(int count = 0; count <= numberOfInputs; count++)
        {
            weights[count] = weight.get(count);
        }
        return weights;
    }

     public Double getWeight(int count)
     {
        return weight.get(count);
    }

    public Double getBias()
    {
        return weight.get(numberOfInputs);
    }


    /**
     * getArrayWeights
     * @return Returns the neuron's weights in the form of Arraylist
     */
    public ArrayList<Double> getArrayWeights()
    {
        return weight;
    }

    /**
     * updateWeight
     * Method used for updating the weight during learning
     * @param i ith java position of the weight
     * @param value value to be updated on the weight
     */
    public void updateWeight(int i, double value)
    {
        if(i >= 0 && i <= numberOfInputs)
        {
            weight.set(i, value);
        }
    }

   // sets the no. of inputs
   public void setNumberOfInputs(int n)
   {
      this.n = numberOfInputs;
   }

    /**
     * getNumberOfInputs
     * @return Returns the number of inputs
     */
    public int getNumberOfInputs()
    {
        return this.numberOfInputs;
    }

    /**
     * setWeight
     * sets the weight at the ith java position
     * @param i ith java position
     * @param value value to be set on the weight
     * @throws NeuralException
     */
    public void setWeight(int i,double value) throws NeuralException
    {
        if(i >= 0 && i < numberOfInputs)
        {
            this.weight.set(i, value);
        }
        else
        {
            throw new NeuralException("Invalid weight index");
        }
    }

     public void deactivateBias()
     {
        this.bias = 0.0;
    }

    public void activateBias()
    {
        this.bias = 1.0;
    }

    /**
     * getOutput
     * @return Returns the neuron's output
     */
    public double getOutput()
    {
        return output;
    }

    /**
     * compute
     * Calculates the neuron's output
     */
    public void compute()
    {
        outputBeforeActivation = 0.0;
        if(numberOfInputs > 0)
        {
            if(input != null && weight != null)
            {
                for(int i=0; i<=numberOfInputs; i++)
                {
                    outputBeforeActivation += (i == numberOfInputs ? bias : input.get(i)) * weight.get(i);
                }
            }
        }
        output = activationFunction.compute(outputBeforeActivation);
    }

      public Double derivative(Double[] input)
      {
        Double outputBeforeAct = 0.0;
        if(numberOfInputs > 0)
        {
            if(weight != null)
            {
                for(int i = 0; i <= numberOfInputs; i++)
                {
                    outputBeforeAct += (i == numberOfInputs ? bias : input[i]) * weight.get(i);
                }
            }
        }
        return activationFunction.derivative(outputBeforeAct);
    }

    public ArrayList<Double> calcBatch(ArrayList<ArrayList<Double>> input)
    {
        ArrayList<Double> result = new ArrayList<>();
        for(int i = 0; i < input.size(); i++)
        {
            result.add(0.0);
            Double outputBeforeActivation=0.0;
            for(int j = 0; j < numberOfInputs; j++)
            {
                outputBeforeActivation += (j == numberOfInputs ? bias : input.get(i).get(j)) * weight.get(j);
            }
            result.set(i,activationFunction.compute(outputBeforeActivation));
        }
        return result;
    }

    public ArrayList<Double> derivativeBatch(ArrayList<ArrayList<Double>> input)
    {
        ArrayList<Double> result = new ArrayList<>();
        for(int i = 0; i < input.size(); i++)
        {
            result.add(0.0);
            Double outputBeforeActivation=0.0;
            for(int j = 0; j < numberOfInputs; j++)
            {
                outputBeforeActivation += (j == numberOfInputs ? bias : input.get(i).get(j)) * weight.get(j);
            }
            result.set(i,activationFunction.derivative(outputBeforeActivation));
        }
        return result;
    }

    /**
     * setActivationFunction
     * Sets the activation function of this neuron
     * @param iaf Activation function
     */
    public void setActivationFunction(IActivationFunction iaf)
    {
        this.activationFunction=iaf;
    }

    /**
     * getOutputBeforeActivation
     * @return Returns the weighted sum of the inputs multiplied by weights
     */
    public double getOutputBeforeActivation()
    {
        return outputBeforeActivation;
    }


   /**
     * This method is to display the details of the neuron: input, output, activation function,
     * output before activation and output.
     * @return
     */

     @Override
      public String toString()
      {
         StringBuilder str = new StringBuilder();
         str.append("\n " +this.numberOfInputs);
         str.append ("Neuron Inputs\n");
         for (Double in: input)
         {
      	 	str.append(in.toString());
      	    str.append(" ");
      	 }
         str.append("\n");
         str.append ("Neuron Weights\n");
         for (Double wt: weight)
         {
         	str.append(wt.toString());
         	str.append(" ");
     	 }
         str.append("\n");
         str.append ("S  Output before activation: ") ;
         str.append(String.format("%.6f", this.outputBeforeActivation));

        str.append("\n");
        str.append ("Activation Function: ");
        str.append(this.activationFunction.FunctionName());
        str.append("\n");
        str.append (" g(s) Neuron Output\n");
        str.append(String.format("%.6f", this.output));
        str.append("\n ");

        return str.toString();
      }

}
